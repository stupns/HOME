#DICTS
**Тип даних**: *mutable*.

**Задачі**: [list-comprehension-tasks.](https://github.com/stupns/HOME/blob/master/TASKS/COMPREHENSION/COMPREHENSION_READY.py "List comprehension")

**Словники** - швидкий та гнучкий тип для зіставлення даних. Вони використовуються розробниками для зберігання та
зіставлення даних, а ще вони використовуються самим Python для об'єктів, щоб зберігати інформацію про їх властивості
та методи. А ще словники використовуються для зберігання інформації про локальні та глобальні змінні та взагалі,
словники використовуються у величезній кількості випадків.

Щоб розібратися в глибинному пристрої словників у Python, потрібно розуміти, що таке хеш-таблиці. **Хеш-таблиця** - це 
тип структури даних, в якому адреса (або індексне значення) елемента з даними генерується, використовуючи хеш-функцію.
Ця структура даних дозволяє отримати швидкий доступ до елементів даних, тому що індексне значення елемента по суті є
його ключем. Тобто можна сказати, що хеш-таблиця зберігає пари ключ-значення, але ключ генерується за допомогою хеш-функції.
Функції пошуку та вставки інформації працюють швидко з цим типом, тому що значення ключа по суті стає індексом
масиву, що зберігає дані.

Словники в Python являють собою реалізацію типу хеш-таблиці. Ключі словника відповідають наступним умовам:

- ключ словника - хешуємо, тобто. він виходить у результаті роботи хеш-уючої функції, яка повертає унікальний результат для
кожного унікального значення, переданого їй як аргумент;

- порядок елементів даних у словнику – випадковий, не фіксований.

Про глибші принципи роботи Python з хеш-таблицями розповів якось **Тім Петерс**, який зробив великий внесок у розвиток як Python,
так і CPython. У своєму описі він використовує ряд смішних порівнянь, при моєму перекладі з англійської вони залишилися
колишніми :) Отже, опис хеш-таблиці в Python від Тіма.

---

Хеш-таблиця по суті є безперервним вектором записів, що складаються з слотів. Усього буває три типи слотів:

- Звичайний слот, що зберігає всередині пару ключ-значення. Назвемо його громадянином.
- Ще не використаний слот. Назвемо його незайманим.
- Слот, який колись був громадянином, але потім у нього видалили ключ, а нова актуальна пара ключ-значення ще не була
записана до нього. Назвемо його екскрементом.

Python приймає рішення про зміну розміру таблиці тоді, коли число незайманих стає менш як 1/3 від усіх доступних слотів
таблиці. У такому випадку, дефолтна поведінка Python полягає в тому, щоб подвоювати кількість слотів таблиці доти, доки
вона не досягне свого максимум в 1073741824 слотів. Однак, якщо було зроблено безліч видалень, в результаті яких у
таблиці з'явилося безліч екскрементів, є можливість виникнення ситуації, що незайманих у таблиці буде дуже мало, але
при цьому і городян буде мало, а основне місце буде зайнято екскрементами. У такому разі, замість розширення, Python
ухвалить рішення про стиснення таблиці (мінімальна кількість слотів у таблиці - 4).

Ще одним цікавим моментом у роботі Python з таблицями є те, що для прискорення роботи, після видалення Python не
кидається відразу підраховувати кількість незайманих (насправді, після видалення елемента, Python очікує, що скоро
прийдуть нові дані на місце екскременту, в т.ч. тому нічого не робить відразу). Тому можна сказати зі 100% упевненістю,
що видалення елемента з таблиці не тягне її зменшення. А ось велика послідовність видалень із наступною вставкою,
можливо, призведе до зменшення розмірів. Але впевненим у цьому не можемо бути. Якщо ж мета отримати максимально стислу
таблицю без додавання елементів, слід використовувати метод copy:

``dict = dict.copy()``

*dict.copy()* завжди повертає словник без екскрементів, з мінімально можливим розміром таблиці, при цьому піклуючись про
те, щоб кількість незайманих була не менше ніж 1/3 від загальної кількості слотів.

---

Python словники компактні і швидкі. Компактні вони тому, що по суті є хеш-таблицею, про що ми говорили раніше, а швидкі
Python словники тому, що алгоритм, що хешує, є частиною всіх вбудованих незмінних типів — дуже швидкий.

Всі незмінні вбудовані Python типи надають функцію, що хешує. Ця функція оголошена в type slot-і (про які говорилося
раніше) з ім'ям tp_hash. Розробники можуть використовувати її, використовуючи дандер метод ``__hash__().``
Розмір хеш значень мають такий самий розмір як і покажчик: 64 біти для 64-бітних систем, 32 - для 32, але ці хеш-значення
ніяк не пов'язані з будь-якими адресами пам'яті.

Хеш значення будь-якого об'єкта Python не повинно змінюватися під час його життєвого циклу. Хеші двох незмінних 
сутностей з однаковими значеннями завжди повинні бути однаковими також:

``"hello".__hash__() == ("hel" + "lo").__hash__()  # поверне True``

Крім цього, жодні хеш-колізії також неможливі. Тобто. Два об'єкти з різними значеннями мають повертати різний хеш.
Деякі хеші досить прості. Наприклад, хеші long типу:

``(401).__hash__()  # поверне 401``

``(401123124389798989898).__hash__()  # для великих значень хеш стають комплекснішими, тут хеш поверне 2212283795829936375``

Користувальницькі типи даних можуть визначати власні хеш-уючі функції шляхом імплементації дандер методу ``__hash__()``.
Щоб не винаходити велосипед і не реалізовувати саму хеш-функцію, користувачам типам слід використовувати якусь 
унікальну властивість (яка має бути не змінною, внаслідок доступу до неї тільки на читання), яку згодом можна передати
вбудованій функції hash(), наприклад, ось так:

``class User: 
   def __init__(self, id: int, name: str, address: str): 
      self._id = id``

   ``def __hash__(self): 
      return hash(self._id)``

   ``@property 
   def id(self): 
      return self._id
   ``
   
Визначивши так свій клас, можна буде отримати хеш екземпляра класу:

``bob = User(123884, "Bob Smith", "Townsville, QLD") ``

``hash(bob)  # поверне 123884``

Більш того, екземпляр нашого класу тепер може бути використаний як ключ словника:

``sally = User(123823, "Sally Smith", "Cairns, QLD") ``

``near_reef = {bob: False, sally: True} ``

``near_reef[bob]  # False``

Що стосується структури об'єкта словника - PyDictObject, то він складається з:

- Безпосередньо об'єкта словника PyDictObject, що зберігає в собі дані про розмір, тег версії, ключі та значення (докладніше - нижче).
- Об'єкт ключів словника зберігає ключі та хеш значення для всіх елементів.

<img alt="PyDictObject" height="100%" src="P:\PYTHON\Education\HOME\images-git\PyDictObj.png" title="Py Dict Object Structure" width="100%"/>

Основні властивості PyDictObject-а:

- ma_used - Число елементів у словнику;
- ma_version_tag – номер версії словника;
- ma_keys — покажчик на об'єкт PyDictKeysObject — усі ключі словника
- ma_values ​​- опціональний елемент з масивом значень.

Об'єкт PyDictKeyObject складається з:

- dk_refcnt - лічильник посилань;
- dk_size - Розмір хеш таблиці;
- dk_lookup - lookup функція (детальніше нижче);
- dk_usable — кількість елементів таблиці, коли словник змінює розміри;
- dk_nentries - кількість використаних елементів таблиці;
- dk_indices - хеш таблиця та зіставлення з dk_entries;
- dk_entries - масив об'єктів PyDictKeyEntry з ключами словника

Об'єкт PyDictKeyEntry складається з:

- me_hash - кешований хеш код властивості me_key
- me_key - вказівник на ключ об'єкта
- me_value - вказівник на значення об'єкта
- 
Що стосується lookup функції, то базова послідовність дій lookup функції має такий вигляд:

- Отримати хеш значення об'єкта ob
- Пошукати хеш значення ob у ключах словника та отримати індекс ix
- Якщо індекс ix порожній, функція повертає DKIX_EMPTY (елемент не знайдено)
- Отримати запис ep ключем для отриманого індексу ix. Повернути результат.